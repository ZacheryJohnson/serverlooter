use bevy::prelude::Event;
use uuid::Uuid;
use crate::algorithm::effect::{AlgorithmEffect, AlgorithmEffectValue, AlgorithmEffectValueT};

#[derive(Clone, Event)]
pub struct ExploitEvent {
    pub active_exploit_id: Uuid,
    pub from_player_server: bool,
    pub algorithm_effect: AlgorithmEffect,
    pub potency_roll: Option<AlgorithmEffectValueT>,
    pub value_after_modification: Option<AlgorithmEffectValueT>,
}

impl ExploitEvent {
    pub fn to_loc_string(&self) -> String {
        // ZJ-TODO: the loc part
        match self.algorithm_effect {
            AlgorithmEffect::Siphon { ref potency } => {
                let potency_roll = self.potency_roll
                    .expect(&format!("missing potency_roll: {}", self.algorithm_effect));
                let value_after_modification = self.value_after_modification
                    .expect(&format!("missing value_after_modification: {}", self.algorithm_effect));

                if matches!(potency, AlgorithmEffectValue::Static(_)) {
                    format!("{} for ${}", self.algorithm_effect, value_after_modification)
                } else {
                    format!("{} (rolled {}) for ${}", self.algorithm_effect, potency_roll, value_after_modification)
                }
            }
            AlgorithmEffect::Exfil { ref potency } => {
                let potency_roll = self.potency_roll
                    .expect(&format!("missing potency_roll: {}", self.algorithm_effect));

                if matches!(potency, AlgorithmEffectValue::Static(_)) {
                    format!("{}", self.algorithm_effect)
                } else {
                    format!("{} (rolled {})", self.algorithm_effect, potency_roll)
                }
            }
            AlgorithmEffect::Modify { ref potency, .. } | AlgorithmEffect::Purge { ref potency, .. } => {
                let potency_roll = self.potency_roll
                    .expect(&format!("missing potency_roll: {}", self.algorithm_effect));

                let new_value = self.value_after_modification
                    .expect(&format!("missing value_after_modification: {}", self.algorithm_effect));

                if matches!(potency, AlgorithmEffectValue::Static(_)) {
                    format!("{} to {}", self.algorithm_effect, new_value)
                } else {
                    format!("{} (rolled {}) to {}", self.algorithm_effect, potency_roll, new_value)
                }
            }
            _ => format!("!!! UNSUPPORTED ALGORITHM EFFECT FOR to_loc_string: {:?}", self.algorithm_effect),
        }
    }
}