use std::sync::{Arc, Mutex};
use bevy::prelude::Commands;
use uuid::Uuid;
use crate::algorithm::effect::AlgorithmEffectApplication;
use crate::event::exploit_started::ExploitStarted;
use crate::executor::Executor;
use crate::script::{Script, ScriptExecutor};
use crate::server::Server;

pub struct ExploitTarget {
    pub server: Arc<Mutex<Server>>,
    pub script: Arc<Mutex<Script>>,

    pub id: Uuid,
    script_executor: ScriptExecutor,
}

impl ExploitTarget {
    pub fn new(server: Arc<Mutex<Server>>, script: Arc<Mutex<Script>>) -> ExploitTarget {
        let id = Uuid::new_v4();
        let script_executor = script.lock().unwrap().executor();

        ExploitTarget {
            server,
            script,
            id,
            script_executor,
        }
    }
}

#[derive(Clone)]
pub struct ActiveExploit {
    pub target: Arc<Mutex<ExploitTarget>>,
    pub script: Arc<Mutex<Script>>,
    pub hosting_server: Arc<Mutex<Server>>,
    pub clock_allocation_hz: u64,
    pub connection_max_health: Arc<Mutex<u32>>,
    pub connection_current_health: Arc<Mutex<u32>>,

    pub auto_reconnect: Arc<Mutex<bool>>,
    pub has_connected: Arc<Mutex<bool>>,
    pub id: Uuid,
    script_executor: Arc<Mutex<ScriptExecutor>>,
}

#[derive(Clone)]
pub enum ActiveExploitStatus {
    Disconnected,
    Connecting,
    Running,
}

impl ActiveExploit {
    pub fn new(
        target: Arc<Mutex<ExploitTarget>>,
        script: Arc<Mutex<Script>>,
        hosting_server: Arc<Mutex<Server>>,
        clock_allocation_hz: u64,
        auto_reconnect: bool,
    ) -> ActiveExploit {
        let id = Uuid::new_v4();

        let mut new_exploit = ActiveExploit {
            target,
            script: script.clone(),
            hosting_server,
            clock_allocation_hz,
            id,
            connection_max_health: Arc::default(),
            connection_current_health: Arc::default(),
            script_executor: Arc::default(),
            has_connected: Arc::default(),
            auto_reconnect: Arc::new(Mutex::new(auto_reconnect)),
        };

        new_exploit.restart();
        new_exploit
    }

    pub fn restart(&mut self) {
        // ZJ-TODO: this should be passed in from the server
        self.connection_max_health = Arc::new(Mutex::new(50));
        self.connection_current_health = Arc::new(Mutex::new(0));
        self.script_executor = Arc::new(Mutex::new(self.script.lock().unwrap().clone().into_executor()));
        self.has_connected = Arc::new(Mutex::new(false));
    }

    pub fn start_execution(&mut self) {
        self.script_executor.lock().unwrap().start_execution();
    }

    pub fn stop_execution(&mut self) {
        self.script_executor.lock().unwrap().stop_execution();
    }

    pub fn progress(&self) -> u64 {
        self.script_executor.lock().unwrap().progress()
    }

    pub fn total_instructions(&self) -> u64 {
        self.script_executor.lock().unwrap().total_instructions()
    }

    pub fn status(&self) -> ActiveExploitStatus {
        if *self.has_connected.lock().unwrap() {
            if *self.connection_current_health.lock().unwrap() == 0 {
                ActiveExploitStatus::Disconnected
            } else {
                ActiveExploitStatus::Running
            }
        } else {
            ActiveExploitStatus::Connecting
        }
    }

    pub fn tick(
        &mut self,
        mut commands: &mut Commands,
        host_ticks_since_last: u64,
        target_ticks_since_last: u64
    ) -> (Vec<AlgorithmEffectApplication>, Vec<AlgorithmEffectApplication>) {
        if !*self.has_connected.lock().unwrap() {
            let mut current_health = self.connection_current_health.lock().unwrap();
            let max_health = self.connection_max_health.lock().unwrap();

            let health_increase_per_tick = 1; // ZJ-TODO
            *current_health = (*current_health + health_increase_per_tick).min(*max_health);

            if *current_health >= *max_health {
                *self.has_connected.lock().unwrap() = true;
                self.script_executor.lock().unwrap().start_execution();
                self.target.lock().unwrap().script_executor.start_execution();

                // ZJ-TODO: this should probably be ExploitActive
                //          as we "start" before we're connected
                commands.trigger(ExploitStarted {
                    exploit_id: self.id,
                });
            }

            return (vec![], vec![]);
        }

        let mut exploit_target = self.target.lock().unwrap();
        let new_host_effects = self.script_executor.lock().unwrap()
            .tick_execution(host_ticks_since_last)
            .into_iter()
            .map(|effect| AlgorithmEffectApplication {
                host_server: self.hosting_server.clone(),
                target_server: exploit_target.server.clone(),
                effect,
                script: self.script.clone(),
            })
            .collect();

        if self.script_executor.lock().unwrap().is_complete() {
            std::mem::swap(
                &mut self.script_executor,
                &mut Arc::new(Mutex::new(self.script.lock().unwrap().executor()))
            );
            self.script_executor.lock().unwrap().start_execution();
        }

        let new_target_effects = exploit_target.script_executor
            .tick_execution(target_ticks_since_last)
            .into_iter()
            .map(|effect| AlgorithmEffectApplication {
                host_server: exploit_target.server.clone(),
                target_server: self.hosting_server.clone(),
                effect,
                script: exploit_target.script.clone(),
            })
            .collect();

        if exploit_target.script_executor.is_complete() {
            let mut new_script_executor = exploit_target.script.lock().unwrap().executor();

            std::mem::swap(
                &mut exploit_target.script_executor,
                &mut new_script_executor,
            );
            exploit_target.script_executor.start_execution();
        }

        (new_host_effects, new_target_effects)
    }
}