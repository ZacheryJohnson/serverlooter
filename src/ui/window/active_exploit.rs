use std::sync::{Arc, Mutex};
use crate::get_localized;
use bevy::prelude::{Commands};
use bevy_egui::egui;
use bevy_egui::egui::{Context, Widget};
use crate::{loc, lock_and_clone, PlayerState};
use crate::active_exploit::{ActiveExploit, ActiveExploitStatus};
use crate::event::exploit_event::ExploitEvent;
use crate::event::request_pause_exploit::RequestPauseExploitEvent;
use crate::event::request_restart_exploit::RequestRestartExploitEvent;
use crate::event::request_stop_exploit::RequestStopExploitEvent;
use crate::macros::clock_speed_to_loc_args;
use crate::server::ServerStats;
use crate::ui::window::Window;

pub struct ActiveExploitWindow {
    pub open: bool,
    pub logs_stick_to_bottom: bool,
    pub active_exploit: Arc<Mutex<ActiveExploit>>,
    pub event_log: Vec<ExploitEvent>,
}

impl ActiveExploitWindow {
    pub fn new(active_exploit: Arc<Mutex<ActiveExploit>>) -> Self {
        ActiveExploitWindow {
            open: true,
            logs_stick_to_bottom: true,
            active_exploit,
            event_log: vec![],
        }
    }
}

impl Window for ActiveExploitWindow {
    fn update(
        &mut self,
        commands: &mut Commands,
        ctx: &Context,
        player_state: &PlayerState
    ) {
        // ZJ-TODO: we should be able to re-open windows once closed
        //          using self.open works for closing it, but there's no way to re-open it
        //          should be able to do so from the Servers panel
        let mut zj_todo_window_open = true;

        let active_exploit = self.active_exploit.lock().unwrap();
        let window = egui::Window::new("Active Exploit")
            .id(format!("active_exploit_{}", active_exploit.id.to_string()).into())
            .fade_in(true)
            .fade_out(true)
            .open(&mut zj_todo_window_open);
        window.show(&ctx, |ui| {
            ui.label(format!("Your Server: {}", lock_and_clone!(active_exploit.hosting_server, name)));
            ui.label(format!("Target Server: {}", lock_and_clone!(active_exploit.target, server, name)));
            let stat_values = lock_and_clone!(active_exploit.target, server, stats).stat_values();
            for (stat_type, stat_value) in stat_values {
                ui.label(format!("\t{stat_type:?}: {stat_value}"));
            }

            ui.label(format!("Allocated CPU: {}",
                loc!(
                    player_state,
                    "ui_server_clock_speed",
                    clock_speed_to_loc_args(active_exploit.clock_allocation_hz)
                )
            ));
            egui::widgets::ProgressBar::new(active_exploit.progress() as f32 / active_exploit.total_instructions() as f32)
                .desired_width(ui.available_width() / 2.0)
                .corner_radius(0.0)
                .show_percentage()
                .ui(ui);

            {
                let current_health = active_exploit.connection_current_health.lock().unwrap().clone() as f32;
                let max_health = active_exploit.connection_max_health.lock().unwrap().clone() as f32;
                let text = match active_exploit.status() {
                    ActiveExploitStatus::Disconnected => "Connection lost",
                    ActiveExploitStatus::Connecting => "Connecting...",
                    ActiveExploitStatus::Running => "Connection terminating..."
                }.to_string();

                egui::widgets::ProgressBar::new(current_health / max_health)
                    .desired_width(ui.available_width() / 2.0)
                    .corner_radius(0.0)
                    .text(text)
                    .ui(ui);
            }

            ui.horizontal(|ui| {
                match active_exploit.status() {
                    ActiveExploitStatus::Running => {
                        if ui.button("Pause").clicked() {
                            commands.trigger(RequestPauseExploitEvent { exploit_id: active_exploit.id });
                        }
                    }
                    ActiveExploitStatus::Disconnected => {
                        if !*active_exploit.auto_reconnect.lock().unwrap() {
                            if ui.button("Connect").clicked() {
                                commands.trigger(RequestRestartExploitEvent { exploit_id: active_exploit.id })
                            }
                        }
                    }
                    _ => {}
                }
                if ui.button(loc!(player_state, "ui_confirmation_stop")).clicked() {
                    commands.trigger(RequestStopExploitEvent {
                        exploit_id: active_exploit.id,
                    });
                }

                let checkbox = ui.add_enabled(
                    player_state.player_unlocks.exploit_auto_reconnect,
                    egui::Checkbox::new(&mut *active_exploit.auto_reconnect.lock().unwrap(), "Auto Reconnect")
                );

                checkbox.on_disabled_hover_ui(|ui| {
                    ui.label("Unlocked in Market");
                });
            });

            ui.heading("Exploit Logs");
            egui::Frame::group(ui.style())
                .corner_radius(1.0)
                .show(ui, |ui| {
                    let row_height = ui.text_style_height(&egui::TextStyle::Body);
                    let maximum_rows = 5;
                    egui::ScrollArea::vertical()
                        .auto_shrink([false, false])
                        .max_height(row_height * (1f32 + maximum_rows as f32)) // extra buffer?
                        .show_rows(ui, row_height, self.event_log.len(), |ui, row_range| {
                            let mut maybe_last_label = None;
                            for event in &self.event_log {
                                let alignment = if event.from_player_server { egui::Align::LEFT } else { egui::Align::RIGHT };
                                ui.with_layout(egui::Layout::top_down(alignment), |ui| {
                                    let label = ui.label(event.to_loc_string());
                                    maybe_last_label = Some(label);
                                });
                            }

                            // If we scroll back to the bottom, become sticky again
                            self.logs_stick_to_bottom = row_range.end == self.event_log.len();

                            // We could use egui::ScrollArea::vertical().stick_to_bottom,
                            // but this gives a nice scrolling animation
                            if let Some(last) = maybe_last_label && self.logs_stick_to_bottom {
                                last.scroll_to_me(Some(egui::Align::BOTTOM));
                            }
                        });
                });
        });
    }
}