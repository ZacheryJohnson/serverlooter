use std::sync::{Arc, Mutex};
use crate::get_localized;
use bevy::prelude::Commands;
use bevy_egui::egui;
use bevy_egui::egui::{Context, Ui, Widget};
use crate::{loc, lock_and_clone, PlayerState};
use crate::active_exploit::{ActiveExploit, ActiveExploitStatus};
use crate::event::request_pause_exploit::RequestPauseExploitEvent;
use crate::event::request_restart_exploit::RequestRestartExploitEvent;
use crate::event::request_stop_exploit::RequestStopExploitEvent;
use crate::macros::clock_speed_to_loc_args;
use crate::server::ServerStats;
use crate::ui::window::Window;

pub struct ActiveExploitWindow {
    pub open: bool,

    pub active_exploit: Arc<Mutex<ActiveExploit>>,
}

impl ActiveExploitWindow {
    pub fn new(active_exploit: Arc<Mutex<ActiveExploit>>) -> Self {
        ActiveExploitWindow {
            open: true,
            active_exploit,
        }
    }
}

impl Window for ActiveExploitWindow {
    fn update(
        &mut self,
        commands: &mut Commands,
        ctx: &Context,
        player_state: &PlayerState
    ) {
        // ZJ-TODO: we should be able to re-open windows once closed
        //          using self.open works for closing it, but there's no way to re-open it
        //          should be able to do so from the Servers panel
        let mut zj_todo_window_open = true;

        let active_exploit = self.active_exploit.lock().unwrap();
        let window = egui::Window::new("Active Exploit")
            .id(format!("active_exploit_{}", active_exploit.id.to_string()).into())
            .fade_in(true)
            .fade_out(true)
            .open(&mut zj_todo_window_open);
        window.show(&ctx, |ui| {
            ui.label(format!("Your Server: {}", lock_and_clone!(active_exploit.hosting_server, name)));
            ui.label(format!("Target Server: {}", lock_and_clone!(active_exploit.target, server, name)));
            let stat_values = lock_and_clone!(active_exploit.target, server, stats).stat_values();
            for (stat_type, stat_value) in stat_values {
                ui.label(format!("\t{stat_type:?}: {stat_value}"));
            }

            ui.label(format!("Allocated CPU: {}",
                loc!(
                    player_state,
                    "ui_server_clock_speed",
                    clock_speed_to_loc_args(active_exploit.clock_allocation_hz)
                )
            ));
            egui::widgets::ProgressBar::new(active_exploit.progress() as f32 / active_exploit.total_instructions() as f32)
                .desired_width(ui.available_width() / 2.0)
                .corner_radius(0.0)
                .show_percentage()
                .ui(ui);

            {
                let current_health = active_exploit.connection_current_health.lock().unwrap().clone() as f32;
                let max_health = active_exploit.connection_max_health.lock().unwrap().clone() as f32;
                let text = match active_exploit.status() {
                    ActiveExploitStatus::Disconnected => "Connection lost",
                    ActiveExploitStatus::Connecting => "Connecting...",
                    ActiveExploitStatus::Running => "Connection terminating..."
                }.to_string();

                egui::widgets::ProgressBar::new(current_health / max_health)
                    .desired_width(ui.available_width() / 2.0)
                    .corner_radius(0.0)
                    .text(text)
                    .ui(ui);
            }

            ui.horizontal(|ui| {
                match active_exploit.status() {
                    ActiveExploitStatus::Running => {
                        if ui.button("Pause").clicked() {
                            commands.trigger(RequestPauseExploitEvent { exploit_id: active_exploit.id });
                        }
                    }
                    ActiveExploitStatus::Disconnected => {
                        if !*active_exploit.auto_reconnect.lock().unwrap() {
                            if ui.button("Connect").clicked() {
                                commands.trigger(RequestRestartExploitEvent { exploit_id: active_exploit.id })
                            }
                        }
                    }
                    _ => {}
                }
                if ui.button(loc!(player_state, "ui_confirmation_stop")).clicked() {
                    commands.trigger(RequestStopExploitEvent {
                        exploit_id: active_exploit.id,
                    });
                }

                let checkbox = ui.add_enabled(
                    player_state.player_unlocks.exploit_auto_reconnect,
                    egui::Checkbox::new(&mut *active_exploit.auto_reconnect.lock().unwrap(), "Auto Reconnect")
                );

                checkbox.on_disabled_hover_ui(|ui| {
                    ui.label("Unlocked in Market");
                });
            });
        });
    }
}